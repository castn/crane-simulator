import sys

from PyQt6 import QtWidgets
from PyQt6.QtWidgets import QApplication
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg, NavigationToolbar2QT as NavigationToolbar
from matplotlib.figure import Figure

from MainWindow import Ui_MainWindow
import crane
import numpy as np


class matplotlib_canvas(FigureCanvasQTAgg):
    def __init__(self, parent=None, width=5, height=4, dpi=100):
        self.fig = Figure(figsize=(width, height), dpi=dpi)
        self.axes = self.fig.add_subplot(111)
        super(matplotlib_canvas, self).__init__(self.fig)


class MainWindow(QtWidgets.QMainWindow, Ui_MainWindow):
    def __init__(self):
        super(MainWindow, self).__init__()
        # Call the autogenerated Ui_MainWindow.py, generated from the .ui file using the command "pyuic6 mainwindow.ui -o MainWindow.py"
        self.setupUi(self)

        # sc = matplotlib_canvas(self, width=5, height=4, dpi=100)
        # sc.axes.plot([0, 1, 2, 3, 4], [10, 1, 20, 3, 40])
        crane.create_crane()
        sc = self.create_plot

        # Create toolbar, passing canvas as first parament, parent (self, the MainWindow) as second.
        # plot_toolbar = NavigationToolbar(sc, self)
        # # Add toolbar and canvas to window
        # self.plot_layout.addWidget(plot_toolbar)
        self.plot_layout.addWidget(sc)

        self.apply_button.clicked.connect(self.apply_configuration)


    def apply_configuration(self):
        self.output.appendPlainText(f"Tower values: [{self.towerHeight_spinbox.value()},{self.towerWidth_spinbox.value()},{self.towerSegment_spinbox.value()},{self.towerSupportType_comboBox.currentText()}]")
        self.output.appendPlainText(f"Jib values: [{self.jibLength_spinBox.value()},{self.jibLength_spinBox.value()},{self.jibLength_spinBox.value()},{self.jibSupportType_comboBox.currentText()}]")
        self.output.appendPlainText(f"CounterJib values: [{self.counterJibLength_spinBox.value()},{self.counterJibHeight_spinBox.value()},{self.counterJibSegments_spinBox.value()},{self.counterJibSupportType_comboBox.currentText()}]")
        
        if self.towerBox.isChecked():
            crane.set_tower_dims(self.towerHeight_spinbox.value(), self.towerWidth_spinbox.value(),
                             self.towerSegment_spinbox.value(), self.towerSupportType_comboBox.currentText())
        if self.jibBox.isChecked():
            crane.set_jib_dims(self.jibLength_spinBox.value(), self.jibLength_spinBox.value(), self.jibLength_spinBox.value())
        if self.counterJibBox.isChecked():
            crane.set_counterjib_dims(self.counterJibLength_spinBox.value(), self.counterJibHeight_spinBox.value(),
                                  self.counterJibSegments_spinBox.value(), self.counterJibSupportType_comboBox.currentText())
        
        self.output.appendPlainText(f"Enable FEM: [{self.enableFEM_checkbox.isChecked()}]")
        if self.enableFEM_checkbox.isChecked():
            N, R, U = crane.analyze()
            self.analysis.appendPlainText('Axial Forces (positive = tension, negative = compression)')
            self.analysis.appendPlainText(N[np.newaxis].T)
            self.analysis.appendPlainText('Reaction Forces (positive = upward, negative = downward)')
            self.analysis.appendPlainText(R)
            self.analysis.appendPlainText('Deformation at nodes')
            self.analysis.appendPlainText(U)
        self.output.appendPlainText("------")
        self.progressBar.setValue(100)
    
    
    def create_plot(self, U):
        nodes, beams = crane.get_crane()
        
        self.plot(nodes, beams, 'gray', '--', 'Undeformed')
        scale = 10 # increase to make more evident in plot
        deformed_nodes = U * scale + nodes
        self.plot(deformed_nodes, beams, 'red', '-', 'Deformed')


    def plot(self, nodes, beams, color, line_style, label):
        """
        Plot nodes using matplotlib
        :param nodes: Numpy array containing the coordinates of each node in three-dimensional space
        :param beams: Array containing the nodes each beam is connected to
        :param color: Color of the edge
        :param line_style: Style of the edge
        :param pen_width: Width of the edge
        :param label: Name of the edge and what it should represent
        """

        for i in range(len(beams)):
            # Create initial and final coordinates
            xi, xf = nodes[beams[i, 0], 0], nodes[beams[i, 1], 0]
            yi, yf = nodes[beams[i, 0], 1], nodes[beams[i, 1], 1]
            zi, zf = nodes[beams[i, 0], 2], nodes[beams[i, 1], 2]
            # Create a Line3D object in list
            line = self.axes.plot([xi, xf], [yi, yf], [zi, zf], color=color, linestyle=line_style, linewidth=1)
            # Override list with first element in list, always the Line3D object.
            line = line[0]
        line.set_label(label)
        self.fig.legend(prop={'size': 10})




# You need one (and only one) QApplication instance per application.
# Pass in sys.argv to allow command line arguments for your app.
# If you know you won't use command line arguments QApplication([]) works too.
app = QApplication(sys.argv)

# Create a Qt widget, which will be our window.
window = MainWindow()
window.show()  # IMPORTANT!!!!! Windows are hidden by default.

# Start the event loop.
app.exec()

# Will not be reached until application is closed
